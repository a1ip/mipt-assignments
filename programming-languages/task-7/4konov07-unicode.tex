\documentclass[10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian, english]{babel}

\usepackage{amssymb, amsmath, textcomp, tabularx, graphicx}

\newcolumntype{C}{>{\centering\arraybackslash}X}%

\title{Задание 7}
\author{Коновалов Андрей, 074}
\date{}

\let \eps \varepsilon

\begin{document}

\maketitle

\noindent
\begin{tabularx}{\textwidth}{|C|C|C|C|C|C|C|C|}
  \hline
  0 & 1 & 2 & 3 & 4 & 5 & 6 & $\sigma$ \\
  \hline
  &&&&&&& \\
  \hline
\end{tabularx}

\bigskip

{\bf Задача 2}

Алгоритм построения грамматики следующий. Модифицируем $D$ так, что бы он стал детерминированным N-автоматом, принимающем язык $L_{\$}$, отличающийся от $L$ тем, что в конец каждого слова приписана буква $\$$. Затем по полученному автомату алгоритмом из теории построим однозначную грамматику, принимающую $L_{\$}$. Допишем в полученную грамматику правило $\$ \rightarrow \eps$. Полученная грамматика будет однозначной и принимать $L$.

Единственный неочевидный шаг - это построение детерминированного N-автомата. Алгоритм построения следующий. Добавим новое состояние $q_s$ и сделаем его начальным. Единственным переходом из него будет переход вида $(\eps, z_0, z_0 \$)$ в бывшее начальное состояние исходного автомата, дописывающий после начального символа стека знак $\$$. Добавим новое состояние $q_f$. Из каждого финального состояния исходного автомата добавим переход вида $(\$, ?, \eps)$ в $q_f$. Из $q_f$ будет переход сам в себя вида $(\eps, ?, \eps)$, опустошающий стек. Каждое из финальных состояний исходного автомата сделаем нефинальным.

Заметим, что построенный автомат будет детерминированным N-автоматом. При этом он будет принимать любое слово, которое принималось исходным автоматом, поскольку после обработки любого такого слова, автомат окажется в одном из бывших финальных состояний, при в его стеке будет находится хотя бы 1 символ ($\$$), а затем перейдет в состояние $q_f$, где и опустошит стек. Новых принимаемых слов не добавится, поскольку слова, не принимаемые исходным автоматом, не переведут итоговый автомат в финальное состояние.

\medskip

{\bf Задача 3}

{\bf (i)}
Очевидно включение $L(G_3) \subseteq L_1$. Докажем $L_1 \subseteq L(G_3)$ индукцией по длине $n$ слова.

{\it База.} При $n = 0$, $\eps \in L(G_3)$.

{\it Переход.} Пусть для всех слов длины меньше $n$ утверждение выполняется. Посмотрим на слово $w \in L_1$ длины $n$.

Заведем счетчик, равный 0 изначально, который уменьшает свое значение на $1$, если встречает букву $b$ и увеличивает на $1$, если встречает букву $a$. Будем идти по слову $w$ пока счетчик не обнулится в первый раз (кроме изначального).

Если после этого мы не дошли до конца слова $w$, то $w$ представимо ввиде $xy$, где $x \in L_1$, $y \in L_1$, а значит, используя правило $S \rightarrow SS$ и выводы слов $x$ и $y$, можно вывести слово $w$ в $G_3$.

Если счетчик обнулился после обработки последнего символа в первый раз, то последняя буква слова $w$ должна отличаться от первой. А значит слово $w$ представимо ввиде $w = axb$ или $w = bxa$, где $x \in L_1$. А значит, используя вывод слова $x$ и правило $S \rightarrow aSb$ или $S \rightarrow bSa$, можно вывести слово $w$.

\smallskip

{\bf (ii)}
Приведем два правых вывода слова $ab$ в $G_3$:
\begin{align*}
  S \rightarrow& SS \rightarrow S \eps \rightarrow aSb \rightarrow ab \\
  S \rightarrow& SS \rightarrow SaSb \rightarrow Sa \eps b \rightarrow ab
\end{align*}

\smallskip

{\bf (iii)}
Допустим, что язык не обладает префиксным свойством, при этом для него удалось построить детерминированный N-автомат. Если язык не обладает префиксным свойством, то в нем есть два слова вида: $x$ и $xy$, причем $|y| > 0$. Поскольку автомат детерминированный, то слово $x$ может быть обработано единственным способом. Поскольку $x$ принимается автоматом, то после обработки слова $x$ стек пуст, но тогда следующий такт невозможен и слово $xy$ не может быть принято. Противоречие, следовательно N-автомат построить нельзя.

Язык $L_1$ не обладает префиксным свойством, т.к. содержит слова $ab$ и $abab$. Следовательно для него нельзя построить N-автомат.

\smallskip

{\bf (iv)}
Да, поскольку из любого состояния все переходы различны как пары $(l, Z)$, где $l$ - буква перехода, $Z$ - верхний символ стека, а так же для любого состояния, из которого есть переход вида $(\eps, Z)$, нет переходов вида $(?, Z)$.

\smallskip

{\bf (v)}
Нет. $P_1$ удовлетворяет как определению СА, так и определению расширенного СА.

\smallskip

{\bf (vi)}
Докажем, что $L(P_1) = L_1$. Пронумеруем состояния: начальное - $q_0$, верхнее - $q_b$, нижнее - $q_a$.

Докажем, что $q_0$ "собирает" слова, имеющие одинаковое количество букв $a$ и $b$, причем в стеке записан только символ $z$. $q_a$ - слова, содержащие больше либо равно букв $a$, чем $b$, причем в стеке записано столько букв $a$, насколько их содержание превосходит содержание букв $b$ в слове, а затем символ $z$. $q_b$ аналогично $q_a$, только оно считает превосходство букв $b$ над $a$.

Изначально автомат находится в состоянии $q_0$. Поскольку обработанное слово $\eps$ содержит одинаковое количество букв $a$ и $b$, а в стеке записан символ $z$, то утверждение выполняется.

Пусть после обработки префикса слова автомат находится в состоянии $q_0$, а значит префикс содержит равное количество букв $a$ и $b$. Если слово было обработано полностью, то оно будет принято. Если следующая буква слова это $a$, то автомат перейдет в состояние $q_a$, а в стек допишется буква $a$. Аналогично, если следующая буква $b$ - в состояние $q_b$, допишется $b$. При этом количество букв $a$ ($b$) в обработанном префиксе будет на 1 превосходить количество $b$ ($a$). Утверждение выполняется.

Пусть после обработки префикса слова автомат находится в состоянии $q_a$. Если на вершине стека находится буква $a$, а следующая буква слова это $a$, то она допишется в стек. Если следующая буква это $b$, то из стека сотрется 1 буква $a$. Если на вершине стека находится символ $z$, то это означает, что количество букв $a$ равно количеству букв $b$ в обработанном префиксе, а автомат перейдет по $\eps$-переходу в $q_0$, поскольку других переходов по символу стека $z$ нет. Во всех случаях утверждение выполняется.

Аналогично разбираются переходы из состояния $q_b$.

\smallskip

{\bf (vii)}
Построим детерминированный N-автомат, эквивалентный данному. Добавим новое состояние $q_s$ и сделаем его начальным. Добавим переход $(\eps, z, z \$)$ в $q_0$. Добавим новое состояние $q_f$. Из состояния $q_0$ добавим переходы $(\$, a, \eps)$, $(\$, b, \eps)$, $(\$, z, \eps)$, $(\$, \$, \eps)$ в $q_f$. Из $q_f$ добавим переходы $(\eps, a, \eps)$, $(\eps, b, \eps)$, $(\eps, z, \eps)$, $(\eps, \$, \eps)$ в $q_f$.

Теперь по полученному автомату, в соответствии с алгоритмом из теории, построим однозначную грамматику, и добавим в нее правило $\$ \rightarrow \eps$.

\medskip

{\bf Задача 4}

Докажем, что данный язык не удовлетворяет лемме о разрастании, а значит не является КС-языком.

Для $\forall C > 0$, возьмем слово $w = a^c b^c a^c b^c$. Посмотрим на любое его разбиение $w = uvzxy$, такое что $|vx| > 0$, $|vzx| < C$.

Будем говорить, что слово $w$ состоит из четырех частей: первая ($a^c$), вторая ($b^c$), третья ($a^c$) и четвертая ($b^c$).

Если $v$ или $x$ содержит $a$ и $b$, то при $i = 2$, слово $u v^i z x^i y \notin L$, т.к. при последовательном проходе по его буквам "переходов" между $a$ и $b$ будет больше, чем 3.

Если одно из слов $v$ или $x$ состоит только из $a$, а второе - только из $b$, то при $i = 2$, слово $u v^i z x^i y \notin L$, т.к. не сохранится баланс букв между первой и третьей частью, поскольку слово, состоящее только из $a$ является подсловом либо первой, либо третьей части.

Пусть оба слова $v$ и $x$ состоят только из букв $a$ или $b$. Тогда они оба являются подсловом одной и той же части, т.к. иначе не выполнится $|vzx| < C$, поскольку $z$ является всем, что стоит между словами $v$ и $x$ в слове $w$. Но в этом случае при $i = 2$ так же не выполняется баланс букв $a$ или $b$, в зависимости от того из каких букв состоят слова $v$ и $x$.

\medskip

{\bf Задача 5}

{\bf (i)}
В данной грамматике нет бесполезных символов. Покажем, что все символы не бесполезные:
\begin{align*}
  A: S \rightarrow ABC \rightarrow Aab \rightarrow ab \\
  B: S \rightarrow ABC \rightarrow \eps Bb \rightarrow ab \\
  C: S \rightarrow ABC \rightarrow \eps a C \rightarrow ab
\end{align*}

{\bf (ii)}
В данной грамматике нет циклов. Любой вывод из нетерминала $C$ будет содержать хотя бы один из терминалов $a$ или $b$, а значит цикла не будет. Любой вывод из $B$ либо будет содержать терминал $a$, либо в некоторый момент будет иметь вид $CC$, а значит при дальнейшем выводе будет содержать $a$ или $b$. Любой вывод из $A$ будет либо $\eps$, либо в некоторый момент будет иметь вид $B$, а значит при дальнейшем выводе будет содержать $a$ или $b$. При выводе из $S$ цикла не получится, поскольку $S$ не содержится в правой части никакого правила.

\smallskip

{\bf (iii)}
Избавимся от $\eps$-правила $A \rightarrow \eps$, добавив для каждого правила, содержащему в правой части $A$, его копию, заменив в ней $A$ на $\eps$:
\begin{align*}
  S \rightarrow& ABC | BC \\
  A \rightarrow& B \\
  B \rightarrow& CC | a \\
  C \rightarrow& AAa | Aa | a | b
\end{align*}

\smallskip

{\bf (iv)}
Приведем грамматику к бинарной форме в несколько шагов, используя эквивалентные преобразования. Шаг 1 уже указан в пункте (iii).

Шаг 2. Избавляемся от правила $A \rightarrow B$.
\begin{align*}
  S \rightarrow& BBC | BC \\
  B \rightarrow& CC | a \\
  C \rightarrow& BBa | Ba | a | b
\end{align*}

Шаг 3. Делаем так, что бы в правой части любого правила не стояли терминалы с нетерминалами.
\begin{align*}
  S \rightarrow& BBC | BC \\
  B \rightarrow& CC | a \\
  D \rightarrow& a \\
  C \rightarrow& BBD | BD | a | b
\end{align*}

Шаг 4. Разбиваем правила в тремя нетерминалами с правой части на два.
\begin{align*}
  E \rightarrow& BC \\
  S \rightarrow& BE | BC \\
  B \rightarrow& CC | a \\
  D \rightarrow& a \\
  F \rightarrow& BD \\
  C \rightarrow& BF | BD | a | b
\end{align*}

\end{document}
